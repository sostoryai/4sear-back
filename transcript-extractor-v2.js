import YTDlpWrap from 'yt-dlp-wrap';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

class AdvancedTranscriptExtractor {
  constructor() {
    this.ytdlp = new YTDlpWrap();
  }

  async extractTranscript(videoId) {
    console.log(`Starting advanced transcript extraction for: ${videoId}`);
    
    try {
      // Method 1: Extract subtitle files directly
      const subtitleResult = await this.extractSubtitles(videoId);
      if (subtitleResult.success) {
        return subtitleResult;
      }

      // Method 2: Try auto-generated captions
      const autoResult = await this.extractAutoGeneratedCaptions(videoId);
      if (autoResult.success) {
        return autoResult;
      }

      return {
        success: false,
        error: 'No transcripts available for this video',
        method: 'none'
      };

    } catch (error) {
      console.error('Advanced extraction error:', error.message);
      return {
        success: false,
        error: error.message,
        method: 'none'
      };
    }
  }

  async extractSubtitles(videoId) {
    try {
      const url = `https://www.youtube.com/watch?v=${videoId}`;
      
      // Try to get subtitle list first
      const subtitleList = await this.ytdlp.execPromise([
        url,
        '--list-subs',
        '--no-warnings'
      ]);

      console.log('Available subtitles:', subtitleList);

      // Languages to try in order of preference
      const languages = ['ko', 'en', 'ja', 'es', 'fr', 'de'];
      
      for (const lang of languages) {
        try {
          console.log(`Trying to extract ${lang} subtitles...`);
          
          const tempDir = path.join(__dirname, 'temp');
          if (!fs.existsSync(tempDir)) {
            fs.mkdirSync(tempDir, { recursive: true });
          }

          const outputTemplate = path.join(tempDir, `${videoId}_${lang}.%(ext)s`);
          
          await this.ytdlp.execPromise([
            url,
            '--write-subs',
            '--write-auto-subs',
            '--sub-lang', lang,
            '--sub-format', 'vtt',
            '--skip-download',
            '--output', outputTemplate,
            '--no-warnings'
          ]);

          // Look for generated subtitle file
          const possibleFiles = [
            path.join(tempDir, `${videoId}_${lang}.${lang}.vtt`),
            path.join(tempDir, `${videoId}_${lang}.vtt`),
            path.join(tempDir, `${videoId}_${lang}.${lang}.auto.vtt`)
          ];

          for (const filePath of possibleFiles) {
            if (fs.existsSync(filePath)) {
              console.log(`Found subtitle file: ${filePath}`);
              const content = fs.readFileSync(filePath, 'utf8');
              const transcript = this.parseVTT(content);
              
              // Cleanup
              this.cleanupTempFiles(tempDir);
              
              if (transcript.length > 50) {
                return {
                  success: true,
                  transcript,
                  language: lang,
                  method: 'yt-dlp-subtitles'
                };
              }
            }
          }
        } catch (langError) {
          console.log(`${lang} subtitle extraction failed:`, langError.message);
        }
      }

      return { success: false };
    } catch (error) {
      console.error('Subtitle extraction error:', error.message);
      return { success: false };
    }
  }

  async extractAutoGeneratedCaptions(videoId) {
    try {
      const url = `https://www.youtube.com/watch?v=${videoId}`;
      
      console.log('Trying auto-generated captions...');
      
      const tempDir = path.join(__dirname, 'temp');
      if (!fs.existsSync(tempDir)) {
        fs.mkdirSync(tempDir, { recursive: true });
      }

      const outputTemplate = path.join(tempDir, `${videoId}_auto.%(ext)s`);
      
      await this.ytdlp.execPromise([
        url,
        '--write-auto-subs',
        '--sub-format', 'vtt',
        '--skip-download',
        '--output', outputTemplate,
        '--no-warnings'
      ]);

      // Look for any generated auto subtitle files
      const files = fs.readdirSync(tempDir).filter(file => 
        file.startsWith(`${videoId}_auto`) && file.endsWith('.vtt')
      );

      for (const file of files) {
        const filePath = path.join(tempDir, file);
        const content = fs.readFileSync(filePath, 'utf8');
        const transcript = this.parseVTT(content);
        
        if (transcript.length > 50) {
          this.cleanupTempFiles(tempDir);
          
          // Extract language from filename
          const langMatch = file.match(/\.([a-z]{2})\.vtt$/);
          const language = langMatch ? langMatch[1] : 'auto';
          
          return {
            success: true,
            transcript,
            language,
            method: 'yt-dlp-auto-captions'
          };
        }
      }

      this.cleanupTempFiles(tempDir);
      return { success: false };
    } catch (error) {
      console.error('Auto caption extraction error:', error.message);
      return { success: false };
    }
  }

  parseVTT(content) {
    try {
      const lines = content.split('\n');
      const textLines = [];
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        
        // Skip VTT headers, timestamps, and empty lines
        if (line === '' || 
            line.startsWith('WEBVTT') || 
            line.includes('-->') ||
            /^\d+$/.test(line) ||
            line.startsWith('NOTE')) {
          continue;
        }
        
        // Clean up the text
        const cleanedLine = line
          .replace(/<[^>]*>/g, '') // Remove HTML tags
          .replace(/&lt;/g, '<')
          .replace(/&gt;/g, '>')
          .replace(/&amp;/g, '&')
          .replace(/&quot;/g, '"')
          .trim();
        
        if (cleanedLine.length > 0) {
          textLines.push(cleanedLine);
        }
      }
      
      return textLines.join(' ').replace(/\s+/g, ' ').trim();
    } catch (error) {
      console.error('VTT parsing error:', error.message);
      return '';
    }
  }

  cleanupTempFiles(tempDir) {
    try {
      if (fs.existsSync(tempDir)) {
        const files = fs.readdirSync(tempDir);
        for (const file of files) {
          fs.unlinkSync(path.join(tempDir, file));
        }
      }
    } catch (error) {
      console.log('Cleanup warning:', error.message);
    }
  }
}

async function extractAdvancedTranscript(videoId) {
  const extractor = new AdvancedTranscriptExtractor();
  return await extractor.extractTranscript(videoId);
}

export { extractAdvancedTranscript };

// CLI usage
if (import.meta.url === `file://${process.argv[1]}`) {
  const videoId = process.argv[2];
  if (!videoId) {
    console.log('Usage: node transcript-extractor-v2.js VIDEO_ID');
    process.exit(1);
  }
  
  extractAdvancedTranscript(videoId)
    .then(result => {
      console.log(JSON.stringify(result, null, 2));
    })
    .catch(error => {
      console.error('Error:', error.message);
      process.exit(1);
    });
}